<?php

namespace App\Http\Controllers\API\TrainingCenter;

use App\Http\Controllers\Controller;
use App\Models\Certificate;
use App\Models\CertificateCode;
use App\Models\CertificateTemplate;
use App\Models\TrainingClass;
use App\Services\CertificateGenerationService;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Str;
use OpenApi\Attributes as OA;

class CertificateController extends Controller
{
    protected $certificateGenerationService;

    public function __construct(CertificateGenerationService $certificateGenerationService)
    {
        $this->certificateGenerationService = $certificateGenerationService;
    }
    #[OA\Get(
        path: "/training-center/certificates",
        summary: "List certificates",
        description: "Get all certificates generated by the training center with optional filtering.",
        tags: ["Training Center"],
        security: [["sanctum" => []]],
        parameters: [
            new OA\Parameter(name: "status", in: "query", schema: new OA\Schema(type: "string", enum: ["valid", "expired", "revoked"]), example: "valid"),
            new OA\Parameter(name: "course_id", in: "query", schema: new OA\Schema(type: "integer"), example: 1),
            new OA\Parameter(name: "type", in: "query", schema: new OA\Schema(type: "string", enum: ["instructor", "trainee"]), example: "trainee", description: "Filter by certificate type: instructor or trainee"),
            new OA\Parameter(name: "search", in: "query", schema: new OA\Schema(type: "string"), example: "John Doe", description: "Search by trainee name, certificate number, or course name"),
            new OA\Parameter(name: "per_page", in: "query", schema: new OA\Schema(type: "integer"), example: 15),
            new OA\Parameter(name: "page", in: "query", schema: new OA\Schema(type: "integer"), example: 1)
        ],
        responses: [
            new OA\Response(
                response: 200,
                description: "Certificates retrieved successfully",
                content: new OA\JsonContent(
                    properties: [
                        new OA\Property(property: "certificates", type: "array", items: new OA\Items(type: "object")),
                        new OA\Property(property: "pagination", type: "object")
                    ]
                )
            ),
            new OA\Response(response: 401, description: "Unauthenticated"),
            new OA\Response(response: 404, description: "Training center not found")
        ]
    )]
    public function index(Request $request)
    {
        $user = $request->user();
        $trainingCenter = \App\Models\TrainingCenter::where('email', $user->email)->first();

        if (!$trainingCenter) {
            return response()->json(['message' => 'Training center not found'], 404);
        }

        $query = Certificate::where('training_center_id', $trainingCenter->id)
            ->with(['course.acc', 'instructor', 'template']);

        if ($request->has('course_id')) {
            $query->where('course_id', $request->course_id);
        }

        if ($request->has('status')) {
            $query->where('status', $request->status);
        }

        // Filter by type (instructor or trainee)
        if ($request->has('type') && in_array($request->type, ['instructor', 'trainee'])) {
            $type = $request->type;
            if ($type === 'instructor') {
                // Instructor certificates: instructor_id is set AND trainee_name matches instructor's name
                $query->whereNotNull('instructor_id')
                    ->whereExists(function ($subQuery) {
                        $subQuery->select(DB::raw(1))
                            ->from('instructors')
                            ->whereColumn('instructors.id', 'certificates.instructor_id')
                            ->whereRaw("LOWER(TRIM(CONCAT(COALESCE(instructors.first_name, ''), ' ', COALESCE(instructors.last_name, '')))) = LOWER(TRIM(certificates.trainee_name))");
                    });
            } else {
                // Trainee certificates: trainee_name doesn't match instructor's name OR instructor_id is null
                $query->where(function ($q) {
                    $q->whereNull('instructor_id')
                        ->orWhereDoesntHave('instructor')
                        ->orWhereNotExists(function ($subQuery) {
                            $subQuery->select(DB::raw(1))
                                ->from('instructors')
                                ->whereColumn('instructors.id', 'certificates.instructor_id')
                                ->whereRaw("LOWER(TRIM(CONCAT(COALESCE(instructors.first_name, ''), ' ', COALESCE(instructors.last_name, '')))) = LOWER(TRIM(certificates.trainee_name))");
                        });
                });
            }
        }

        // Search functionality
        if ($request->has('search') && !empty($request->search)) {
            $searchTerm = $request->search;
            $query->where(function ($q) use ($searchTerm) {
                $q->where('trainee_name', 'like', "%{$searchTerm}%")
                    ->orWhere('certificate_number', 'like', "%{$searchTerm}%")
                    ->orWhere('verification_code', 'like', "%{$searchTerm}%")
                    ->orWhereHas('course', function ($courseQuery) use ($searchTerm) {
                        $courseQuery->where('name', 'like', "%{$searchTerm}%");
                    });
            });
        }

        // Sort by newest first (created_at descending)
        $query->orderBy('created_at', 'desc');

        $perPage = $request->get('per_page', 15);
        $certificates = $query->paginate($perPage);

        // Transform certificates data
        $transformedCertificates = $certificates->getCollection()->map(function ($certificate) {
            $data = $certificate->toArray();
            
            // Change trainee_name to name
            if (isset($data['trainee_name'])) {
                $data['name'] = $data['trainee_name'];
                unset($data['trainee_name']);
            }
            
            // Determine type: instructor or trainee using database query
            // Instructor certificates: instructor_id is set AND trainee_name matches instructor's name
            $isInstructorCertificate = false;
            if ($certificate->instructor_id) {
                $exists = DB::table('instructors')
                    ->where('instructors.id', $certificate->instructor_id)
                    ->whereRaw("LOWER(TRIM(CONCAT(COALESCE(instructors.first_name, ''), ' ', COALESCE(instructors.last_name, '')))) = LOWER(TRIM(?))", [$certificate->trainee_name])
                    ->exists();
                
                if ($exists) {
                    $isInstructorCertificate = true;
                }
            }
            
            $data['type'] = $isInstructorCertificate ? 'instructor' : 'trainee';
            
            return $data;
        });

        // Replace the collection in paginator
        $certificates->setCollection($transformedCertificates);

        return response()->json($certificates);
    }

    #[OA\Get(
        path: "/training-center/certificates/{id}",
        summary: "Get certificate details",
        description: "Get detailed information about a specific certificate.",
        tags: ["Training Center"],
        security: [["sanctum" => []]],
        parameters: [
            new OA\Parameter(name: "id", in: "path", required: true, schema: new OA\Schema(type: "integer"), example: 1)
        ],
        responses: [
            new OA\Response(
                response: 200,
                description: "Certificate retrieved successfully",
                content: new OA\JsonContent(
                    properties: [
                        new OA\Property(property: "certificate", type: "object")
                    ]
                )
            ),
            new OA\Response(response: 401, description: "Unauthenticated"),
            new OA\Response(response: 404, description: "Certificate not found")
        ]
    )]
    public function show($id)
    {
        $user = request()->user();
        $trainingCenter = \App\Models\TrainingCenter::where('email', $user->email)->first();

        if (!$trainingCenter) {
            return response()->json(['message' => 'Training center not found'], 404);
        }

        $certificate = Certificate::where('training_center_id', $trainingCenter->id)
            ->with(['course', 'instructor', 'trainingCenter', 'template'])
            ->findOrFail($id);
        
        // Transform certificate data
        $certificateData = $certificate->toArray();
        
        // Change trainee_name to name
        if (isset($certificateData['trainee_name'])) {
            $certificateData['name'] = $certificateData['trainee_name'];
            unset($certificateData['trainee_name']);
        }
        
        // Determine type: instructor or trainee
        // Instructor certificates: instructor_id is set AND trainee_name matches instructor's name
        // Trainee certificates: instructor_id might be set (teacher) but trainee_name doesn't match instructor's name
        $isInstructorCertificate = false;
        if ($certificate->instructor_id && $certificate->instructor) {
            $instructorFullName = trim(($certificate->instructor->first_name ?? '') . ' ' . ($certificate->instructor->last_name ?? ''));
            $traineeName = trim($certificate->trainee_name ?? '');
            // Check if trainee_name matches instructor's name (certificate is FOR the instructor)
            if (!empty($instructorFullName) && strtolower($traineeName) === strtolower($instructorFullName)) {
                $isInstructorCertificate = true;
            }
        }
        
        $certificateData['type'] = $isInstructorCertificate ? 'instructor' : 'trainee';
            
        return response()->json(['certificate' => $certificateData]);
    }

    #[OA\Get(
        path: "/training-center/certificates/{id}/validity",
        summary: "Check certificate validity",
        description: "Check if a certificate is valid. Returns certificate status and validity information.",
        tags: ["Training Center"],
        security: [["sanctum" => []]],
        parameters: [
            new OA\Parameter(name: "id", in: "path", required: true, schema: new OA\Schema(type: "integer"), example: 99)
        ],
        responses: [
            new OA\Response(
                response: 200,
                description: "Certificate validity checked successfully",
                content: new OA\JsonContent(
                    properties: [
                        new OA\Property(property: "valid", type: "boolean", example: true),
                        new OA\Property(property: "status", type: "string", example: "valid"),
                        new OA\Property(property: "certificate", type: "object"),
                        new OA\Property(property: "message", type: "string", example: "Certificate is valid")
                    ]
                )
            ),
            new OA\Response(response: 401, description: "Unauthenticated"),
            new OA\Response(response: 403, description: "Certificate does not belong to this training center"),
            new OA\Response(response: 404, description: "Certificate not found")
        ]
    )]
    public function checkValidity($id)
    {
        $user = request()->user();
        $trainingCenter = \App\Models\TrainingCenter::where('email', $user->email)->first();

        if (!$trainingCenter) {
            return response()->json(['message' => 'Training center not found'], 404);
        }

        $certificate = Certificate::where('training_center_id', $trainingCenter->id)
            ->with(['course', 'instructor', 'trainingCenter', 'template'])
            ->findOrFail($id);

        // Check if certificate is expired based on expiry_date
        $isExpired = false;
        if ($certificate->expiry_date && $certificate->expiry_date < now()->toDateString()) {
            $isExpired = true;
            // Update status if not already set
            if ($certificate->status !== 'expired') {
                $certificate->update(['status' => 'expired']);
                $certificate->refresh();
            }
        }

        $isValid = $certificate->status === 'valid' && !$isExpired;
        $status = $certificate->status;

        $message = match($status) {
            'valid' => $isExpired ? 'Certificate has expired' : 'Certificate is valid',
            'expired' => 'Certificate has expired',
            'revoked' => 'Certificate has been revoked',
            default => 'Certificate status: ' . $status,
        };

        return response()->json([
            'valid' => $isValid,
            'status' => $status,
            'message' => $message,
            'certificate' => [
                'id' => $certificate->id,
                'certificate_number' => $certificate->certificate_number,
                'verification_code' => $certificate->verification_code,
                'name' => $certificate->trainee_name,
                'type' => (function() use ($certificate) {
                    // Determine type: instructor or trainee
                    if ($certificate->instructor_id && $certificate->instructor) {
                        $instructorFullName = trim(($certificate->instructor->first_name ?? '') . ' ' . ($certificate->instructor->last_name ?? ''));
                        $traineeName = trim($certificate->trainee_name ?? '');
                        if (!empty($instructorFullName) && strtolower($traineeName) === strtolower($instructorFullName)) {
                            return 'instructor';
                        }
                    }
                    return 'trainee';
                })(),
                'issue_date' => $certificate->issue_date,
                'expiry_date' => $certificate->expiry_date,
                'status' => $certificate->status,
                'course' => $certificate->course ? [
                    'id' => $certificate->course->id,
                    'name' => $certificate->course->name,
                ] : null,
                'training_center' => $certificate->trainingCenter ? [
                    'id' => $certificate->trainingCenter->id,
                    'name' => $certificate->trainingCenter->name,
                ] : null,
            ],
        ]);
    }

    #[OA\Get(
        path: "/training-center/certificates/{id}/download",
        summary: "Download certificate file",
        description: "Download the certificate PDF/image file.",
        tags: ["Training Center"],
        security: [["sanctum" => []]],
        parameters: [
            new OA\Parameter(name: "id", in: "path", required: true, schema: new OA\Schema(type: "integer"), example: 99)
        ],
        responses: [
            new OA\Response(response: 200, description: "Certificate file downloaded successfully"),
            new OA\Response(response: 401, description: "Unauthenticated"),
            new OA\Response(response: 403, description: "Certificate does not belong to this training center"),
            new OA\Response(response: 404, description: "Certificate or file not found")
        ]
    )]
    public function download($id)
    {
        $user = request()->user();
        $trainingCenter = \App\Models\TrainingCenter::where('email', $user->email)->first();

        if (!$trainingCenter) {
            return response()->json(['message' => 'Training center not found'], 404);
        }

        $certificate = Certificate::where('training_center_id', $trainingCenter->id)
            ->findOrFail($id);

        if (!$certificate->certificate_pdf_url) {
            return response()->json(['message' => 'Certificate file not found'], 404);
        }

        try {
            // Extract the file path from the URL
            $url = $certificate->certificate_pdf_url;
            
            if (empty($url)) {
                return response()->json(['message' => 'Certificate file URL is empty'], 404);
            }
            
            // Parse the URL to get the path
            $urlPath = parse_url($url, PHP_URL_PATH);
            if (!$urlPath) {
                $urlPath = $url; // Fallback if parse_url fails
            }
            
            // Remove various URL prefixes to get the storage path
            $filePath = $urlPath;
            
            // Remove /v1/api/storage/ or /api/storage/ prefix if present (handle versioned APIs)
            if (preg_match('#(/v\d+/api/storage/|/api/storage/)(.+)$#', $filePath, $matches)) {
                $filePath = $matches[2];
            }
            // Remove /storage/app/public/ prefix if present
            elseif (strpos($filePath, '/storage/app/public/') !== false) {
                $filePath = str_replace('/storage/app/public/', '', $filePath);
            }
            // Remove /storage/ prefix if present (but not /api/storage/)
            elseif (strpos($filePath, '/storage/') === 0 && strpos($filePath, '/api/storage/') === false) {
                $filePath = substr($filePath, strlen('/storage/'));
            }
            
            // Remove leading slash if present
            $filePath = ltrim($filePath, '/');
            
            // Log for debugging
            \Illuminate\Support\Facades\Log::info('Certificate download attempt', [
                'certificate_id' => $id,
                'original_url' => $url,
                'url_path' => $urlPath,
                'parsed_path' => $filePath,
            ]);
            
            // Check if file exists in storage
            if (!\Illuminate\Support\Facades\Storage::disk('public')->exists($filePath)) {
                // List available files in certificates directory for debugging
                $certDir = dirname($filePath);
                $availableFiles = [];
                if (\Illuminate\Support\Facades\Storage::disk('public')->exists($certDir)) {
                    $availableFiles = \Illuminate\Support\Facades\Storage::disk('public')->files($certDir);
                }
                
                \Illuminate\Support\Facades\Log::warning('Certificate file not found', [
                    'certificate_id' => $id,
                    'url' => $url,
                    'url_path' => $urlPath,
                    'parsed_path' => $filePath,
                    'cert_dir' => $certDir,
                    'available_files' => $availableFiles,
                ]);
                
                return response()->json([
                    'message' => 'Certificate file not found on server',
                    'debug' => config('app.debug') ? [
                        'url' => $url,
                        'url_path' => $urlPath,
                        'parsed_path' => $filePath,
                        'cert_dir' => $certDir,
                    ] : null
                ], 404);
            }

            $fullPath = \Illuminate\Support\Facades\Storage::disk('public')->path($filePath);
            $mimeType = \Illuminate\Support\Facades\Storage::disk('public')->mimeType($filePath) ?? 'application/pdf';
            $fileName = basename($filePath);

            return response()->download($fullPath, $fileName, [
                'Content-Type' => $mimeType,
            ]);

        } catch (\Illuminate\Database\Eloquent\ModelNotFoundException $e) {
            return response()->json(['message' => 'Certificate not found'], 404);
        } catch (\Exception $e) {
            \Illuminate\Support\Facades\Log::error('Certificate download error', [
                'certificate_id' => $id,
                'url' => $certificate->certificate_pdf_url ?? 'N/A',
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString(),
            ]);

            return response()->json([
                'message' => 'Failed to download certificate',
                'error' => config('app.debug') ? $e->getMessage() : 'An error occurred',
            ], 500);
        }
    }

    #[OA\Get(
        path: "/training-center/certificates/accs",
        summary: "Get authorized ACCs for certificate generation",
        description: "Get all authorized ACCs that the training center can generate certificates for.",
        tags: ["Training Center"],
        security: [["sanctum" => []]],
        responses: [
            new OA\Response(
                response: 200,
                description: "ACCs retrieved successfully",
                content: new OA\JsonContent(
                    properties: [
                        new OA\Property(property: "accs", type: "array", items: new OA\Items(type: "object"))
                    ]
                )
            ),
            new OA\Response(response: 401, description: "Unauthenticated"),
            new OA\Response(response: 404, description: "Training center not found")
        ]
    )]
    public function getAuthorizedAccs(Request $request)
    {
        $user = $request->user();
        $trainingCenter = \App\Models\TrainingCenter::where('email', $user->email)->first();

        if (!$trainingCenter) {
            return response()->json(['message' => 'Training center not found'], 404);
        }

        // Get authorized ACC IDs
        $authorizedAccIds = DB::table('training_center_acc_authorization')
            ->where('training_center_id', $trainingCenter->id)
            ->where('status', 'approved')
            ->pluck('acc_id');

        // Get ACCs with their info
        $accs = \App\Models\ACC::whereIn('id', $authorizedAccIds)
            ->select('id', 'name', 'logo_url')
            ->get();

        return response()->json(['accs' => $accs]);
    }

    #[OA\Post(
        path: "/training-center/certificates",
        summary: "Issue a new certificate",
        description: "Generate and issue a new certificate. The system will automatically select an available purchase code if not provided. Select ACC and Course, enter student name. Optionally provide a specific purchase code. The system will automatically select the appropriate template and generate the certificate. The purchase code will be marked as used.",
        tags: ["Training Center"],
        security: [["sanctum" => []]],
        requestBody: new OA\RequestBody(
            required: true,
            content: new OA\JsonContent(
                required: ["acc_id", "course_id", "trainee_name", "issue_date"],
                properties: [
                    new OA\Property(property: "acc_id", type: "integer", example: 1, description: "ID of the authorized ACC"),
                    new OA\Property(property: "course_id", type: "integer", example: 1, description: "ID of the course from the selected ACC"),
                    new OA\Property(property: "training_class_id", type: "integer", nullable: true, example: 1, description: "ID of the training class. If provided, the class must have a status of 'completed'."),
                    new OA\Property(property: "instructor_id", type: "integer", nullable: true, example: 1),
                    new OA\Property(property: "trainee_name", type: "string", example: "John Doe", description: "Student name"),
                    new OA\Property(property: "trainee_id_number", type: "string", nullable: true, example: "ID123456"),
                    new OA\Property(property: "issue_date", type: "string", format: "date", example: "2024-01-15"),
                    new OA\Property(property: "expiry_date", type: "string", format: "date", nullable: true, example: "2026-01-15"),
                    new OA\Property(property: "purchase_code", type: "string", nullable: true, example: "ABC123XYZ", description: "Optional purchase code. If not provided, the system will automatically select an available code. If provided, it must be available and belong to the training center for the selected ACC.")
                ]
            )
        ),
        responses: [
            new OA\Response(response: 201, description: "Certificate issued successfully"),
            new OA\Response(response: 401, description: "Unauthenticated"),
            new OA\Response(response: 403, description: "ACC not authorized or course not available"),
            new OA\Response(response: 404, description: "ACC, Course, Template, or Training Class not found"),
            new OA\Response(response: 422, description: "Validation error or training class is not completed")
        ]
    )]
    public function store(Request $request)
    {
        $user = $request->user();
        $trainingCenter = \App\Models\TrainingCenter::where('email', $user->email)->first();

        if (!$trainingCenter) {
            return response()->json(['message' => 'Training center not found'], 404);
        }

        $request->validate([
            'acc_id' => 'required|exists:accs,id',
            'course_id' => 'required|exists:courses,id',
            'training_class_id' => 'nullable|exists:training_classes,id',
            'instructor_id' => 'nullable|exists:instructors,id',
            'trainee_name' => 'required|string|max:255',
            'trainee_id_number' => 'nullable|string|max:255',
            'issue_date' => 'required|date',
            'expiry_date' => 'nullable|date|after:issue_date',
            'purchase_code' => 'nullable|string|exists:certificate_codes,code',
        ]);

        // Verify ACC is authorized
        $isAuthorized = DB::table('training_center_acc_authorization')
            ->where('training_center_id', $trainingCenter->id)
            ->where('acc_id', $request->acc_id)
            ->where('status', 'approved')
            ->exists();

        if (!$isAuthorized) {
            return response()->json(['message' => 'ACC is not authorized for this training center'], 403);
        }

        // Get course and verify it belongs to the selected ACC
        $course = \App\Models\Course::with(['acc', 'subCategory.category'])->findOrFail($request->course_id);
        
        if ($course->acc_id != $request->acc_id) {
            return response()->json(['message' => 'Course does not belong to the selected ACC'], 403);
        }

        // Check training class status - certificates can only be generated for completed classes
        $trainingClass = null;
        
        if ($request->has('training_class_id') && $request->training_class_id) {
            // If training_class_id is explicitly provided, check it
            $trainingClass = TrainingClass::where('id', $request->training_class_id)
                ->where('training_center_id', $trainingCenter->id)
                ->where('course_id', $request->course_id)
                ->first();

            if (!$trainingClass) {
                return response()->json([
                    'message' => 'Training class not found, does not belong to this training center, or does not match the selected course'
                ], 404);
            }
        } else {
            // If training_class_id is not provided, check if there are any training classes for this course
            // that have trainees matching the trainee name
            $traineeName = trim($request->trainee_name);
            
            // Try to find trainees with matching name
            $matchingTrainees = \App\Models\Trainee::where('training_center_id', $trainingCenter->id)
                ->where(function ($query) use ($traineeName) {
                    // Match full name
                    $query->whereRaw("CONCAT(first_name, ' ', last_name) = ?", [$traineeName])
                        ->orWhereRaw("CONCAT(last_name, ' ', first_name) = ?", [$traineeName])
                        // Also try matching if trainee_name contains first_name or last_name
                        ->orWhere('first_name', 'like', "%{$traineeName}%")
                        ->orWhere('last_name', 'like', "%{$traineeName}%");
                })
                ->pluck('id');

            if ($matchingTrainees->isNotEmpty()) {
                // Find training classes for this course that have these trainees enrolled
                $trainingClass = TrainingClass::where('training_center_id', $trainingCenter->id)
                    ->where('course_id', $request->course_id)
                    ->whereHas('trainees', function ($query) use ($matchingTrainees) {
                        $query->whereIn('trainees.id', $matchingTrainees);
                    })
                    ->first();
            }
        }

        // If a training class is found (either explicitly or by trainee matching), verify it's completed
        if ($trainingClass) {
            if ($trainingClass->status !== 'completed') {
                return response()->json([
                    'message' => 'Certificates can only be generated for completed classes',
                    'class_status' => $trainingClass->status,
                    'class_id' => $trainingClass->id,
                    'class_name' => $trainingClass->name,
                    'hint' => 'The training class must have a status of "completed" before certificates can be generated. Please mark the class as completed first.'
                ], 422);
            }
        }

        // Get or automatically select purchase code
        $purchaseCode = null;
        
        if ($request->has('purchase_code') && !empty($request->purchase_code)) {
            // If purchase code is provided, validate it
            $purchaseCode = CertificateCode::where('code', $request->purchase_code)
                ->where('training_center_id', $trainingCenter->id)
                ->where('acc_id', $request->acc_id)
                ->first();

            if (!$purchaseCode) {
                return response()->json([
                    'message' => 'Purchase code not found or does not belong to this training center for the selected ACC'
                ], 404);
            }

            // Verify code is available
            if ($purchaseCode->status !== 'available') {
                return response()->json([
                    'message' => 'Purchase code is not available',
                    'code_status' => $purchaseCode->status,
                    'details' => match($purchaseCode->status) {
                        'used' => 'This code has already been used for another certificate',
                        'expired' => 'This code has expired',
                        'revoked' => 'This code has been revoked',
                        default => 'Code status: ' . $purchaseCode->status,
                    }
                ], 422);
            }

            // Verify code matches the course (if code has a specific course assigned)
            if ($purchaseCode->course_id && $purchaseCode->course_id != $request->course_id) {
                return response()->json([
                    'message' => 'Purchase code is not valid for this course',
                    'code_course_id' => $purchaseCode->course_id,
                    'requested_course_id' => $request->course_id,
                ], 422);
            }
        } else {
            // Automatically select an available purchase code
            // First, try to find a course-specific code
            $purchaseCode = CertificateCode::where('training_center_id', $trainingCenter->id)
                ->where('acc_id', $request->acc_id)
                ->where('course_id', $request->course_id)
                ->where('status', 'available')
                ->orderBy('purchased_at', 'asc') // FIFO - oldest first
                ->first();

            // If no course-specific code found, try to find a general code (no course_id)
            if (!$purchaseCode) {
                $purchaseCode = CertificateCode::where('training_center_id', $trainingCenter->id)
                    ->where('acc_id', $request->acc_id)
                    ->whereNull('course_id')
                    ->where('status', 'available')
                    ->orderBy('purchased_at', 'asc') // FIFO - oldest first
                    ->first();
            }

            // If still no code found, return error
            if (!$purchaseCode) {
                return response()->json([
                    'message' => 'No available purchase codes found for this course and ACC. Please purchase certificate codes first.',
                    'hint' => 'You need to purchase certificate codes before generating certificates. Go to the Codes section to purchase codes.',
                    'acc_id' => $request->acc_id,
                    'course_id' => $request->course_id,
                ], 422);
            }
        }

        // Find template: first check for course-specific template (via pivot table), then fall back to category template
        $categoryId = $course->subCategory->category_id ?? null;
        
        if (!$categoryId) {
            return response()->json(['message' => 'Course category not found'], 422);
        }

        // First, try to find a template that has this course in its courses array (many-to-many)
        $template = CertificateTemplate::where('acc_id', $request->acc_id)
            ->where('status', 'active')
            ->whereHas('courses', function ($query) use ($request) {
                $query->where('courses.id', $request->course_id);
            })
            ->first();

        // If no template found via courses relationship, check legacy course_id field
        if (!$template) {
            $template = CertificateTemplate::where('acc_id', $request->acc_id)
                ->where('course_id', $request->course_id)
                ->where('status', 'active')
                ->first();
        }

        // If no course-specific template found, fall back to category template
        if (!$template) {
            $template = CertificateTemplate::where('acc_id', $request->acc_id)
                ->where('category_id', $categoryId)
                ->whereNull('course_id') // Ensure it's a category template, not a course template
                ->whereDoesntHave('courses') // Also ensure it doesn't have courses via pivot
                ->where('status', 'active')
                ->whereNotNull('background_image_url')
                ->whereNotNull('config_json')
                ->first();
        }

        if (!$template) {
            return response()->json([
                'message' => 'No certificate template found for this ACC and course. Please ensure the ACC has created a certificate template for this course or its category.',
                'hint' => 'The system checks for course-specific templates first, then falls back to category templates'
            ], 404);
        }

        // Check if there's already a certificate for this trainee for this course
        // A trainee can only have one certificate per course
        $existingCertificate = Certificate::where('course_id', $request->course_id)
            ->where('training_center_id', $trainingCenter->id)
            ->where('trainee_name', $request->trainee_name)
            ->whereIn('status', ['valid', 'expired']) // Check for valid or expired certificates
            ->first();

        if ($existingCertificate) {
            return response()->json([
                'message' => 'A certificate already exists for this trainee for this course. Each trainee can only have one certificate per course.',
                'existing_certificate' => [
                    'id' => $existingCertificate->id,
                    'certificate_number' => $existingCertificate->certificate_number,
                    'verification_code' => $existingCertificate->verification_code,
                    'status' => $existingCertificate->status,
                    'issue_date' => $existingCertificate->issue_date,
                    'course_id' => $existingCertificate->course_id,
                    'course_name' => $course->name,
                ]
            ], 409); // Conflict status code
        }

        try {
            // Generate certificate number and verification code
            $certificateNumber = $this->generateCertificateNumber();
            $verificationCode = $this->generateVerificationCode();
            
            // Auto-generate student_data from course information
            $certificateData = [
                'student_name' => $request->trainee_name,
                'trainee_name' => $request->trainee_name,
                'course_name' => $course->name,
                'date' => $request->issue_date,
                'cert_id' => $certificateNumber,
                'certificate_number' => $certificateNumber,
                'issue_date' => $request->issue_date,
                'expiry_date' => $request->expiry_date ?? null,
                'verification_code' => $verificationCode, // Add verification code to template data
            ];

            // Create certificate record first (with temporary URL or placeholder)
            // Use the training_class_id from request if provided, otherwise use the found class
            $certificateTrainingClassId = $request->training_class_id ?? ($trainingClass ? $trainingClass->id : null);
            
            $certificate = Certificate::create([
                'certificate_number' => $certificateNumber,
                'course_id' => $request->course_id,
                'training_class_id' => $certificateTrainingClassId,
                'training_center_id' => $trainingCenter->id,
                'instructor_id' => $request->instructor_id,
                'trainee_name' => $request->trainee_name,
                'trainee_id_number' => $request->trainee_id_number,
                'issue_date' => $request->issue_date,
                'expiry_date' => $request->expiry_date,
                'template_id' => $template->id,
                'certificate_pdf_url' => '', // Will be updated immediately
                'verification_code' => $verificationCode,
                'status' => 'valid',
                'code_used_id' => $purchaseCode->id, // Link certificate to purchase code
            ]);

            // Mark the purchase code as used
            $purchaseCode->update([
                'status' => 'used',
                'used_at' => now(),
                'used_for_certificate_id' => $certificate->id,
            ]);

            // Generate certificate PDF immediately
            $generationResult = $this->certificateGenerationService->generate($template, $certificateData, 'pdf');

            if (!$generationResult['success']) {
                // Update certificate status on failure
                $certificate->update([
                    'status' => 'revoked',
                ]);

                // Revert purchase code status if certificate generation failed
                $purchaseCode->update([
                    'status' => 'available',
                    'used_at' => null,
                    'used_for_certificate_id' => null,
                ]);

                return response()->json([
                    'message' => 'Failed to generate certificate PDF',
                    'error' => $generationResult['message'] ?? 'Unknown error',
                ], 500);
            }

            // Update certificate with PDF URL
            $certificate->update([
                'certificate_pdf_url' => $generationResult['file_url'],
                'status' => 'valid',
            ]);

            // Reload certificate from database to ensure all fields including verification_code are included
            $certificate = $certificate->fresh(['course', 'instructor', 'template']);

            return response()->json([
                'message' => 'Certificate generated successfully',
                'certificate' => $certificate,
            ], 201);

        } catch (\Exception $e) {
            \Illuminate\Support\Facades\Log::error('Certificate issuance error', [
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString(),
            ]);

            return response()->json([
                'message' => 'Failed to issue certificate',
                'error' => $e->getMessage(),
            ], 500);
        }
    }

    /**
     * Generate unique certificate number
     */
    private function generateCertificateNumber(): string
    {
        do {
            $number = 'CERT-' . date('Y') . '-' . strtoupper(Str::random(8));
        } while (Certificate::where('certificate_number', $number)->exists());

        return $number;
    }

    /**
     * Generate unique verification code
     */
    private function generateVerificationCode(): string
    {
        do {
            $code = 'VERIFY-' . strtoupper(Str::random(10));
        } while (Certificate::where('verification_code', $code)->exists());

        return $code;
    }
}
